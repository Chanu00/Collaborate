# README 확인 용

- **`형상관리 시스템은 왜 나오게 되었을까요?`**

> 1.  소프트웨어 개발 프로세스의 복잡성이 증가했기 때문입니다. 소프트웨어의 규모가 커지고 개발에 참여하는 인원이 늘어남에 따라 변경사항의 관리와 추적이 더욱 어려워졌습니다. 이에 대한 대응책으로 형상관리 시스템이 개발되어 이전 버전과 변경 내역을 추적하고 관리할 수 있게 되었습니다.

> 2.  소프트웨어의 병렬 개발이 보편화되면서 변경사항의 충돌이 발생하게 되었습니다. 여러 명의 개발자가 동시에 같은 코드를 수정하는 경우 변경사항이 충돌하여 문제가 발생할 수 있습니다. 이를 방지하기 위해 형상관리 시스템에서는 동시 수정을 허용하지 않거나, 충돌 발생 시 해결하는 기능을 제공합니다.

> 3.  버전 관리와 배포 관리가 필요해졌기 때문입니다. 소프트웨어의 다양한 버전이 존재하며, 각 버전에 따라 다른 기능이나 버그가 존재합니다. 이에 대한 관리를 효과적으로 하기 위해서는 형상관리 시스템을 이용하여 각 버전의 변경사항과 배포 이력을 추적해야 합니다.

---

- **`git은 어떤 형상관리 시스템이고 어떤 특징을 가지고 있을까요? 분산형 형상관리 시스템이란 무엇일까요?`**

> 1.  빠른 속도와 분산형 구조를 가지고 있습니다. 이를 통해 매우 큰 프로젝트도 효과적으로 관리할 수 있습니다.

> 2.  브랜치 기능을 지원합니다. 이를 통해 병렬적인 개발이 가능해져서 여러 개발자들이 동시에 작업을 할 수 있습니다.

> 3.  변경 이력을 체계적으로 관리하고 추적할 수 있습니다. Git은 파일의 내용이 아니라 파일의 변경 내용을 저장하므로, 이전 버전과의 차이점을 비교하거나 특정 시점으로 되돌아갈 수 있습니다.

> 4.  유연한 워크플로우를 지원합니다. Git은 개발자나 프로젝트에 따라 다양한 워크플로우를 지원하기 때문에 다양한 프로젝트에서 유용하게 사용될 수 있습니다.

> 5.  다양한 호스팅 서비스와 연동될 수 있습니다. Git은 Github, GitLab, Bitbucket 등의 호스팅 서비스와 연동되어 협업을 용이하게 할 수 있습니다.

---

- **`git은 어떻게 개발되게 되었을까요? git이 분산형 시스템을 채택한 이유는 무엇일까요?`**

> 1.  리누스 토발즈는 중앙 집중형 버전 관리 시스템의 단점을 경험하였습니다. 이전에 사용하던 BitKeeper가 상용이었기 때문에, 커널 개발에 필요한 기능들이나 사용성이 제한되어 있었습니다. 따라서 리누스 토발즈는 이러한 제한된 환경에서 개발하다가 중앙 집중형 버전 관리 시스템의 단점을 실감하게 되었습니다.

> 2.  분산형 시스템은 안정성과 신뢰성을 높일 수 있습니다. 중앙 서버가 다운되면 모든 작업이 중단되는 문제를 방지할 수 있으며, 분산된 저장소를 가지고 있기 때문에 중앙 서버에 저장되어 있지 않은 과거의 버전도 복구할 수 있습니다.

> 3.  분산형 시스템은 개발자들이 독립적으로 작업할 수 있도록 합니다. 분산형 시스템은 로컬 저장소와 원격 저장소를 가지고 있으므로, 개발자들이 서로 독립적으로 작업을 진행하고, 나중에 변경 사항을 병합할 수 있습니다.

---

- **`git과 GitHub은 어떻게 다를까요?`**

> Git은 버전 관리 시스템이고, GitHub은 Git을 사용하는 프로젝트를 호스팅하는 웹 호스팅 서비스입니다. Git은 로컬에서 코드를 관리하고, GitHub은 코드를 공유하고 협업하기 위한 플랫폼입니다.

---

- **`git의 clone/add/commit/push/pull/branch/stash 명령은 무엇이며 어떨 때 이용하나요? 그리고 어떻게 사용하나요?`**

> 1. git clone : 원격 저장소의 내용을 로컬 저장소로 복제합니다.

> 2. git add : 스테이징 영역에 변경사항을 추가 해줍니다.

> 3. git commit : 스테이징 영역에 추가 된 내용을 로컬 저장소로에 커밋 해줍니다.

> 4. git push : 로컬 저장소에 있는 변경사항을 원격 저장소로 업로드 해줍니다.

> 5. git pull : 원격 저장소에 있는 변경사항을 로컬 저장소로 가져옵니다.

> 6. git branch : 현재의 브랜치를 확인하거나 새로운 브랜치를 생성하거나 변경 합니다.

> 7. git stash : 변경 사항을 임시 저장하거나 되돌리기를 합니다.

---

- **`git의 Object, Commit, Head, Branch, Tag는 어떤 개념일까요? git 시스템은 프로젝트의 히스토리를 어떻게 저장할까요?`**

> **Object** :
> Git의 데이터 모델을 구성하는 기본 단위
> 4가지 타입의 오브젝트가 있음: blob, tree, commit, tag
> Git은 모든 파일 변경사항을 내부적으로 blob으로 저장하고, 여러 파일을 묶어서 트리(tree) 오브젝트로 만들어 저장함
> 커밋(commit) 오브젝트는 변경 내용, 작성자, 커밋 메시지, 이전 커밋 등의 정보를 포함하고 있음
> 태그(tag) 오브젝트는 특정 커밋이나 트리에 대한 이름표 역할을 함

> **Commit** :
> Git에서의 커밋은 변경사항을 로컬 저장소에 저장하는 것을 의미
> 새로운 커밋을 만들면, 이전 커밋과의 차이점을 저장하는 새로운 트리 오브젝트를 만들고, 이전 커밋과 새로운 커밋 간의 차이를 설명하는 커밋 오브젝트를 만듦

> **Head** :
> 현재 작업 중인 브랜치의 최신 커밋을 가리키는 포인터
> HEAD는 커밋의 SHA-1 해시 값으로 표시됨

> **Branch** :
> 개발자가 자신의 작업을 분리하여 병렬로 진행하기 위한 개념
> 브랜치를 생성하면 HEAD가 그 브랜치를 가리키게 됨
> 새로운 커밋을 만들면 해당 브랜치가 가리키는 커밋이 변경되고, HEAD 포인터도 새로운 커밋을 가리키게 됨

> **Tag** :
> 특정 커밋이나 트리를 가리키는 이름표 역할을 하는 오브젝트
> 보통 소스 코드의 릴리즈 버전 등에 사용됨

---

- **`리모트 git 저장소에 원하지 않는 파일이 올라갔을 때 이를 되돌리려면 어떻게 해야 할까요?`**

> git rm --cached -r 폴더/파일명 을 통해서 원격 저장소 파일 지우고 삭제 내용을 commit한 후 push한다.

---

- `HTML 표준의 역사는 어떻게 될까요?`

```
1. HTML 1.0: 1991년에 처음으로 표준화된 HTML 버전으로, 웹의 초기 단계에서 사용되었습니다.

2. HTML 2.0: 1995년에 표준화된 HTML 버전으로, 이미지와 링크 등의 요소를 도입하여 웹의 콘텐츠 표현과 링크 기능을 향상시켰습니다.

3. HTML 3.2: 1997년에 표준화된 HTML 버전으로, 표와 양식 요소 등의 기능을 추가하여 웹의 다양한 콘텐츠 표현과 입력 기능을 확장하였습니다.

4.HTML 4.01: 1999년에 표준화된 HTML 버전으로, 프레임, 스타일, 스크립트 등의 요소와 속성을 도입하여 웹의 동적인 기능과 스타일링을 가능하게 하였습니다. 또한, XHTML 1.0 버전도 도입되었는데, XML 기반의 엄격한 문법 규칙을 따르는 버전이었습니다.

5.XHTML 1.1: 2000년에 표준화된 XHTML 버전으로, XHTML 1.0을 엄격한 XML 문법에 따라 개선한 버전이었습니다.

6. HTML5: 2014년에 표준화된 HTML 버전으로, 웹의 다양한 요구사항에 부합하도록 발전한 버전입니다. 비디오, 오디오, 캔버스, 웹 워커, 웹 저장소 등의 새로운 요소와 기능이 도입되었고, 더 개방적인 개발 프로세스와 개발자들의 참여를 통해 발전하였습니다.
```

---

- `HTML 표준을 지키는 것은 왜 중요할까요?`

```
1. 브라우저의 호환성
2. 향 후 호환성
3. 개발자 간 현업 및 유지 보수
4. 접근성
5. 검색 엔진 최적화
```

---

- `XHTML 2.0은 왜 세상에 나오지 못하게 되었을까요?`

```
1. 복잡성과  호환성 문제
2. 시장 요구의 변화
3. 표준화 프로세스와 커뮤니티의 변화
```

---

- `HTML5 표준은 어떤 과정을 통해 정해질까요?`

```
1. HTML Working Group
2. 작업 초안 수립
3. 공개 리뷰
4. 표준 규격
5. 구현과 테스트
6. 업데이트
```

---

- `브라우저의 역사는 어떻게 될까요?`

```
1. 1990년: 첫 웹브라우저 WolrdWideWeb
2. 1993년: NCSA Mosaic
3. 1994년: Netscape Naviator
4.1995년: Inernet Explorer
5. 2003년: Safari
6. 2008년: Google Chrome
```

---

- `Internet Explorer가 브라우저 시장을 독점하면서 어떤 문제가 일어났고, 이 문제는 어떻게 해결되었을까요?`

```
Internet Explorer에서만 작동하는 웹사이트를 만들어야만 했습니다. 브라우저 선택의 자유가 제한되었고 이문제를 해결해기위해 Microsoft Edge를 출시하였습니다.
```

---

- `현재 시점에 브라우저별 점유율은 어떻게 될까요? 이 브라우저별 점유율을 알아보는 것은 왜 중요할까요?`

```
Chrome이 63%로 가장 높은 점유율을 보여주고 있다.
점유율을 알아보는것이 중요한 이유는 사용자들이 어떤 브라우저를 사용하는지에 따라 더 좋은 서비스를 개발하여 제공할 수 있기 때문이다.
```

---

- `브라우저 엔진(렌더링 엔진)이란 무엇일까요? 어떤 브라우저들이 어떤 엔진을 쓸까요?`

```
HTML, CSS, JS 코드를 해석하여 화면에 렌더링하는데 사용되는 핵심 프로그램이다.(웹 브라우저의 성능, 기능, 안정성 및 보안에 영향을 줌)

브라우저 엔진 종류 (* : 많이 사용 됨)
1.Blink *
2.WebKit *
3.Geocko
4.EdgeHTML
5.Trident
```

---

- `모바일 시대 이후, 최근에 출시된 브라우저들은 어떤 특징을 가지고 있을까요?`

```
1. 모바일 최적화: 모바일 기기에서의 사용성을 고려하여 모바일 화면에 최적화된 인터페이스와 기능을 제공합니다.

2. 빠른 성능: 웹 페이지를 빠르게 렌더링하고 사용자의 입력을 빠르게 처리하는 등 빠른 성능을 제공합니다.

3. 새로운 웹 기술 지원: 최신 웹 기술을 지원하여 더 많은 기능을 제공합니다.

4. 보안: 새로운 보안 기능을 제공하여 사용자의 개인 정보와 기기를 보호합니다.

5. 개인화: 사용자의 취향과 관심사에 맞게 개인화된 콘텐츠를 제공합니다.

6. 다양한 플랫폼 지원: 다양한 운영체제와 플랫폼에서 사용할 수 있도록 지원합니다.

7. 인공지능 기술: 인공지능 기술을 활용하여 더 나은 검색 결과, 자동완성, 음성 인식 등을 제공합니다.
```

---

- `HTML 문서는 어떤 구조로 이루어져 있나요?`

```
HTML 문서는 일반적으로 다음과 같은 구조를 가지고 있습니다.

1. <!DOCTYPE html> 선언: 문서가 HTML5로 작성되었음을 나타내는 선언입니다.

2. <html> 요소: HTML 문서의 최상위 요소입니다. 모든 다른 요소들은 이 요소의 하위에 위치합니다.

3. <head> 요소: 문서의 메타데이터, 즉 문서의 제목(title), 문자 인코딩, 외부 스타일 시트, 자바스크립트 파일 등을 정의하는 요소입니다.

4.<title> 요소: 문서의 제목을 정의하는 요소입니다.

5. <body> 요소: 실제 내용이 위치하는 요소입니다. 웹 페이지에서 보여지는 모든 콘텐츠, 즉 텍스트, 이미지, 링크 등이 이 요소 안에 위치합니다.
```

---

- `<head>`에 자주 들어가는 엘리먼트들은 어떤 것이 있고, 어떤 역할을 할까요?

```
1. <meta>: 문서의 메타데이터를 나타내는 요소입니다. charset 속성으로 문자 인코딩을 지정할 수 있으며, name과 content 속성으로 다양한 정보를 추가할 수 있습니다. 예를 들어, <meta name="description" content="웹 페이지에 대한 설명">과 같이 사용할 수 있습니다.

2. <title>: 문서의 제목을 나타내는 요소입니다. 브라우저의 탭에 표시되는 문서의 이름을 정의합니다.
3. <link>: 문서와 외부 리소스를 연결하는 요소입니다. 주로 외부 스타일 시트(CSS)를 연결하는데 사용됩니다.

4. <script>: 자바스크립트 코드를 문서에 포함시키는 요소입니다. 외부 스크립트 파일을 연결할 수도 있습니다.

5. <style>: 문서에 포함된 스타일을 정의하는 요소입니다. CSS 코드를 작성하여 문서에 적용할 수 있습니다.

6. <base>: 상대적인 URL 경로를 기준으로 하이퍼링크를 처리하는 요소입니다. href 속성으로 기본 URL을 지정합니다.
```

---

- `시맨틱 태그는 무엇일까요?`

```
시맨틱 태그는 웹 문서에서 콘텐츠의 의미를 명확하게 설명하는 역할을 하는 태그 입니다. (ex: <header>, <nav>, <footer> )
```

---

- `시맨틱 엘리먼트를 사용하면 어떤 점이 좋을까요?`

```
1. 검색 엔진 최적화
2. 접근성 개선
3. 유지 보수 용이성
4. 코드 가독성 향상
```

---

- _`<section>`과 `<div>`, `<header>`, `<footer>`, `<article>` 엘리먼트의 차이점은 무엇인가요?_

```
<section>은 문서의 일부를 지칭하는 범용 블록 레벨 엘리먼트입니다. 반면에, <div>는 문서의 일부를 그룹화하는 범용 블록 레벨 엘리먼트입니다. 즉, <div>는 개별적인 스타일링을 위해 여러 엘리먼트를 그룹화하는 데 사용되고, <section>은 문서의 구획을 나누기 위해 사용됩니다.

<header>와 <footer>는 각각 문서의 맨 위와 맨 아래에 위치한 블록 레벨 엘리먼트입니다. 일반적으로, <header>는 사이트의 로고, 제목, 메뉴 등과 같은 정보를 포함하는데 사용되며, <footer>는 저작권 정보, 연락처 정보 등과 같은 사이트의 하단 부분에 필요한 정보를 포함하는 데 사용됩니다.

<article>는 독립적으로 구성될 수 있는 하나의 콘텐츠 단위를 나타내는 블록 레벨 엘리먼트입니다. 일반적으로 뉴스 기사, 포스트, 블로그 게시물 등과 같이 하나의 주제나 항목에 대한 내용을 담고 있습니다.
```

---

- `블록 레벨 엘리먼트와 인라인 엘리먼트는 어떤 차이가 있을까요?`

```
 * 블록 레벨 엘리먼트: <div>, <p>, <h1>~<h6>, <ul>, <ol>, <li>, <table>, <form>, <header>, <footer>, <section>, <article>, <nav> 등이 있습니다. 이러한 엘리먼트는 항상 새로운 라인에서 시작하고, 전체 폭을 차지하며, 다른 블록 엘리먼트와 인라인 엘리먼트를 자식으로 포함할 수 있습니다.

* 인라인 엘리먼트: <span>, <a>, <strong>, <em>, <img>, <input>, <label>, <select>, <textarea>, <button> 등이 있습니다. 이러한 엘리먼트는 문장 내에서 사용되며, 자신의 크기만큼의 공간을 차지하며, 다른 인라인 엘리먼트와 함께 사용될 수 있습니다.
```

---
